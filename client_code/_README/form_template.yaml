components:
- layout_properties: {grid_position: 'CMMLNY,VTVCLG'}
  name: image_1
  properties: {display_mode: shrink_to_fit, source: _/theme/icon-logo.png}
  type: Image
- layout_properties: {grid_position: 'OAXTWP,YVBGLO'}
  name: rich_text_1
  properties:
    content: "# Anvil Testing\nDesigned as a dependency app to allow for automated testing within anvil.\nI've tried to stay consistent with pytest where possible to keep things feeling familiar.  \n\nExample test report\n```\n================= Anvil Testing ==================\nFound 13 tests\n\n  Pass: customer_service/test_config::test_event\n> Fail: customer_service/test_config::test_stripe_customers_table - \n\tTable: stripe_customers\n\t - column 'last_update' must be of type 'string' not 'number'\n\t - column 'next_update' not found\n  Pass: customer_service/test_config::test_stripe_events_table\n  Pass: customer_service/test_event_handler::TestUpdate::test_backwards_update\n  Pass: customer_service/test_event_handler::TestUpdate::test_forward_update\n  Pass: customer_service/test_event_handler::TestUpdate::test_missing_key_in_update\n  Pass: customer_service/test_event_handler::TestUpdate::test_missing_row_data\n  Pass: customer_service/test_event_handler::TestUpdateMissing::test_missing\n  Pass: customer_service/test_event_handler::TestUpdateMissing::test_overlap\n  Pass: customer_service/test_event_handler::TestUpdateMissing::test_unknown\n  Pass: customer_service/test_util::test_decode_reference_id\n  Pass: customer_service/test_util::test_encode_and_get_row\n  Pass: customer_service/test_util::test_encode_row_id\n\n12/13 passed\n1 failed tests\n====================== FAIL ======================\n```\n\n## Testing this app\nYou can run the integrated tests of this app from the server REPL console by running the following\n\n``` python\nfrom . import _tests\nfrom . import auto\n_ = auto.run(_tests, quiet=False)\n```\n\n## Testing as a dependency\nInclude this app as a dependency in your app.\nCreate a server module or package where your tests will reside.  Note the structure of this app for an example.\nFor this app I've included tests in the `_test` package to try and keep the imported namespace of this app to a minimum.  This is not required and your test parent directory can by named anything.\n\n## Test Naming\nFunctions should have the prefix `test_`\nClasses should have the prefix `Test`\nClass methods should have the prefix `test_`\nfunctions, classes and methods without the prefix are ignored by test collection.\n\n``` python\ndef test_positive():\n    result = module_a.calculate()\n    assert result > 0, f\"Should always be positive {result}\"\n\n# this is not seen as a test.\ndef setup():\n    return \"something important\"\n\nclass DummyTable:\n    def __init__(self, data):\n        self.data\n\n    def get(self, key):\n        return data.get(key, None)\n\n    def test_result(self):\n        # not seen as part of test pacakge since\n        # class name does not start with `Test`\n        (do something related to the table)\n\nclass TestSuite:\n    def test_a(self):\n        self.setup()\n        assert self.table.get('a') is None\n\n    def test_b(self):\n        assert False, 'Test not implemented'\n\n    def setup(self):\n        # this is not run as a test.\n        self.table = DummyTable({})\n```\n\n## Tests\nTests are run using assert statements.  anvil_testing automatically captures these raised assertions and their message to display test failures.\n\n``` python\nassert True, \"this does absolutely nothing.\"\nassert False, \"this is raised as a test failure.\"\n\nassert minimize() < 1, \"minimize didn't find a result less than 1\"\n\n#assertion messages can be provided as a list, that will be parsed\nbunch_of_errors = ['error 1', 'error 2']\nassert not bunch_of_errors, bunch_of_errors\n```\n\n### Running tests\nWith the test written, you just need to import your test package and `anvil_testing` and run your tests.\n\n#### console\nThe tests can be run from the server REPL console.  The downside here is the console needs to be refreshed after changes are made.  \nYou will get a __click to reload__ message as changes are made.  Putting the three lines into a single block allows for a simple up arrow and enter to run the tests.  Here we are just ignoring the return value since it will print it for us.\nThis will commonly look like this:\n\n``` python\nfrom . import tests\nimport anvil_testing\n_ = anvil_testing.auto.run(tests)\n```\n#### webpage\nYou can create a simple endpoint or route which runs the tests.  Capture the return from the test and place it into the body of a `HttpResponse` and you get a simple text test report page that can be refreshed anytime you want to run the tests.  If you clone or use this as a dependency, you will need to publish a debug environment for the following code to work.\n\nThis assumes you have a structure like:\n```\nserver_code\n  testing/\n    test\n    tests/\n      test_module_1\n      test_module_2\n      ...\n\n```\n\nNote: `anvil_testing` has a modified version of this webpage creation below.\nYou can run the tests on this dependency here: [Test anvil_testing](https://ccw3sylsaqhlcf2a.anvil.app/WP2Y7J7IVWI6XXCQKUZS2OXO/test)\n\n#### test.py\n``` python\nfrom anvil import app\n\n\"\"\"\nCreate a test webpage on the debug environment.\nOpen the server console to see the app specific web address.\n\"\"\"\nif 'debug' in app.environment.tags and app.id in anvil.server.get_app_origin():\n    import anvil.server\n    test_endpoint = '/test'\n    print('Tests can be run here:')\n    print(f\"{anvil.server.get_app_origin('debug')}{test_endpoint}\")\n    \n    @anvil.server.route(test_endpoint)\n    def run() -> anvil.server.HttpResponse:\n        from . import tests\n        import anvil_testing\n        results = anvil_testing.auto.run(tests, quiet=False)\n        return anvil.server.HttpResponse(body=results)\n```\n\n## Helpers\n### Table Validation\nMy thought with the table check is that you could write a dependency app which requires tables then run the tests on the imported dependency to verify you have tables setup correctly in the parent app.\n\n```\nimport anvil_testing\nimport my_dependency\nanvil_testing.auto.run(my_dependency.tests.tables) # the path to your table tests.\n```\nto get information on what still requires setup:\n``` console\n> Fail: tables::test_my_table - \n\tTable: my_table\n\t - column 'last_update' must be of type 'string' not 'number'\n\t - column 'next_update' not found\n```\n\n### Temporary Table Row\nYou can create temporary rows for usage in testing.  The test row is created using a `with` block.  After the block is exited the row is automatically deleted from the table.\n``` python\nwith helpers.temp_row(app_tables.my_table, id='test') as row:\n    # run tests with the row\n\n# Row is automatically remove after leaving the block\n```\n\n### Temporary Table Writes\nIf your tests require additional flexibility, you can enter a temporary write mode that will discard all writes to the table after exiting the block.\n``` python\nwith helpers.temp_writes():\n    new_row = app_tables.my_table.add_row(id='test')\n    row = app_tables.my_table.get(id='abc')\n    row['info'] = 'new info'\n\nrow = app_tables.my_table.get(id='abc')\nprint(row['info']) -> \"previous info\"\nnew_row.get_id() -> raises RowDeleted error.\n```\n\n### Raises\nIt can be helpful to check that your code raised a specific exception when the test runs.  This is done in the same manner as pytest.\n\nExample of `temp_row` and `raises`:\n\n``` python \ndef test_temp_row():\n    with helpers.temp_row(app_tables.my_table, id='TESTING') as row:\n        row['api_version'] = '9'\n        assert row['id'] == 'TESTING'\n        assert row['api_version'] == '9'\n\n    with helpers.raises(tables.RowDeleted):\n        row.get_id()   \n```"
  type: RichText
container: {type: ColumnPanel}
is_package: true
